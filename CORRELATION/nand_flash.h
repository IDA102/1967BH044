#include "DMA.h"
// НЕ ВСЕ РЕГИСТРЫ, ЧАСТЬ РЕГИСТРОВ СОСТОЯНИЯ(READ) НЕ ОПИСАНА
#ifndef nand_flash_H_
#define nand_flash_H_

#define NAND_BASE     (*(uint32_t*)(0x80000240))   // базовый адрес NAND контроллера
#define NAND_IO_CFG   (*(uint32_t*)(NAND_BASE+0))  // регистр конфигурации временных параметров
#define NAND_WCT_CFG  (*(uint32_t*)(NAND_BASE+1))  // pегистр конфигурации времени ожидания
#define NAND_NAND_CFG (*(uint32_t*)(NAND_BASE+2))  // pегистр конфигурации протокола обмена
#define NAND_WR_CFG   (*(uint32_t*)(NAND_BASE+3))  // pегистр команд записи
#define NAND_RD_CFG   (*(uint32_t*)(NAND_BASE+4))  // pегистр команд чтения
#define NAND_CR       (*(uint32_t*)(NAND_BASE+8))  // pегистр управления
#define NAND_SR       (*(uint32_t*)(NAND_BASE+9))  // pегистр состояния
#define NAND_AR       (*(uint32_t*)(NAND_BASE+10)) // pегистр начального адреса обмена
#define NAND_CNTR     (*(uint32_t*)(NAND_BASE+11)) // cчетчик количества передаваемых слов
#define NAND_DR       (*(uint32_t*)(NAND_BASE+12)) // буфер данных
#define NAND_ERR12    (*(uint32_t*)(NAND_BASE+13)) // pегистр номеров ошибок 1 и 2
#define NAND_ERR34    (*(uint32_t*)(NAND_BASE+14)) // pегистр номеров ошибок 3 и 4
#define NAND_SP_BUF   (*(uint32_t*)(NAND_BASE+15)) // pегистр номера ошибочной подстраницы

/*____________________________________IO_CFG____________________________________*/
/*Данный регистр позволяет определить основные временные параметры протокола обмена. 
Длительность стробов выражается количеством тактов частоты синхронизации, на которой работает контроллер. 
В качестве базовой частоты используется частота периферийной шины.
*/

/*(2:0) "CSCA" - Число периодов(+1) CLK с момента активизации NF_CS [2:0] до момента активизации 
        сигналов nRE или nWE.*/ 
//reset default - 111(0x7)
#define NAND_CSCA_1 0x0‬ // 
#define NAND_CSCA_2 0x1 // 
#define NAND_CSCA_3 0x2 // 
#define NAND_CSCA_4 0x3 // 
#define NAND_CSCA_5 0x4 // 
#define NAND_CSCA_6 0x5 // 
#define NAND_CSCA_7 0x6 // 
#define NAND_CSCA_8 0x7 // 

/*(7:3) "CA" - Число периодов (+1) активности сигнала nRE во время чтения памяти.*/ 
//reset default - 11111(0x8F)
#define NAND_CA_1  0x00‬ // 
#define NAND_CA_2  0x08 // 
#define NAND_CA_3  0x10 // 
#define NAND_CA_4  0x18 // 
#define NAND_CA_5  0x20 // 
#define NAND_CA_6  0x28 // 
#define NAND_CA_7  0x30 // 
#define NAND_CA_8  0x‬38 // 
#define NAND_CA_9  0x‬40 // 
#define NAND_CA_10 0x‬48 // 
#define NAND_CA_11 0x50‬ // 
#define NAND_CA_12 0x‬58 // 
#define NAND_CA_13 0x60‬ // 
#define NAND_CA_14 0x‬68 // 
#define NAND_CA_15 0x70‬ // 
#define NAND_CA_16 0x‬78 // 
#define NAND_CA_17 0x80‬ // 
#define NAND_CA_18 0x‬88 // 
#define NAND_CA_19 0x‬90 // 
#define NAND_CA_20 0x‬98 // 
#define NAND_CA_21 0x‬A0 // 
#define NAND_CA_22 0xA8 // 
#define NAND_CA_23 0x‬B0 // 
#define NAND_CA_24 0x‬B8 // 
#define NAND_CA_25 0x‬C0 // 
#define NAND_CA_26 0x‬C8 // 
#define NAND_CA_27 0xD0‬ // 
#define NAND_CA_28 0x‬D8 // 
#define NAND_CA_29 0x‬E0 // 
#define NAND_CA_30 0xE8‬ // 
#define NAND_CA_31 0x‬F0 // 
#define NAND_CA_32 0xF8 //

/*(10:8) "BWD" - Число периодов (+1) активности nWE во время записи.*/ 
//reset default - 111(0x700)
#define NAND_BWD_1 0x0‬00 // 
#define NAND_BWD_2 0x100‬ // 
#define NAND_BWD_3 0x200 // 
#define NAND_BWD_4 0x300 // 
#define NAND_BWD_5 0x400 // 
#define NAND_BWD_6 0x5‬00 // 
#define NAND_BWD_7 0x600 // 
#define NAND_BWD_8 0x700 // 

/*(14:11) "BRT" - Число периодов (+1) от момента снятия одного NF_CSx до момента активизации 
           NF_CSx другого банка, с целью избежать конфликт на шине данных.*/ 
//reset default - 1111(0x7800)
#define NAND_BRT_1  0x0800 // 
#define NAND_BRT_2  0x0100 // 
#define NAND_BRT_3  0x1800 // 
#define NAND_BRT_4  0x2000 // 
#define NAND_BRT_5  0x2800 // 
#define NAND_BRT_6  0x3000 // 
#define NAND_BRT_7  0x3800‬ // 
#define NAND_BRT_8  0x4000‬ // 
#define NAND_BRT_9  0x4800‬ // 
#define NAND_BRT_10 0x5000 // 
#define NAND_BRT_11 0x5800 // 
#define NAND_BRT_12 0x6000 // 
#define NAND_BRT_13 0x6800 // 
#define NAND_BRT_14 0x7000 // 
#define NAND_BRT_15 0x7800 // 

/*(17:15) "BHT" - Число периодов (+1) CLK в течение которых NF_CSx находится в неактивном 
          состоянии между последовательными выборками. А также число периодов (+1) после 
          снятия nRE или nWE до следующего активного сигнала.*/ 
//reset default - 111(0x78000)
#define NAND_BHT_1 0x00‬000 // 
#define NAND_BHT_2 0x08000‬ // 
#define NAND_BHT_3 0x10000 // 
#define NAND_BHT_4 0x18000 // 
#define NAND_BHT_5 0x20000 // 
#define NAND_BHT_6 0x28000 // 
#define NAND_BHT_7 0x30000 // 
#define NAND_BHT_8 0x38000 //

/*(18) "MDT" -Тип интерфейса. Используется совместно с VGA битом.*/ 
//reset default - 0(0x0)
#define NAND_MDT_0 0x00000 // 
#define NAND_MDT_1 0x40000‬ // 

//reset default - 00(0x0)
/*(20:19) - Не используется. Значение безразлично.*/

/*(21) "VGA" - Тип интерфейса. Имеет значение при установленном MDT.*/ 
//reset default - 1(0x200000‬)
#define NAND_VGA_0 0x00‬0000 // 
#define NAND_VGA_1 0x200000 //

/*(22) - Не используется. Значение безразлично.*/

/*(26:23) "CSKPL" - Управление линиями NF_CSx между доступами к флэш-памяти.*/ 
//reset default - 0001(0x800000)
#define NAND_CSKPL_0 0x00‬0000 // линии NF_CSх становятся неактивными между выборками
#define NAND_CSKPL_1 0x800000 // линии NF_CSx активны (=0) между выборками

/*(31:27) - Не используется. Значение безразлично.*/

/*____________________________________WCT_CFG____________________________________*/
/*Регистр позволяет управлять анализом сигнала готовности внешней памяти и 
программировать максимальное время ожидания.*/

/*(3:0) "ENWT" - Разрешение анализа входа RnB во время обмена с одним из банков NF_CS[3:0].*/ 
//reset default - 1111(0xF) NAND_ENWT_1
#define NAND_ENWT_0 0x0‬ // RnB не анализируется
#define NAND_ENWT_1 0xF // RnB используется для анализа во время цикла обмена #define NAND_ENWT_1 0xF‬

/*(7:4) "CCSE" - Разрешение анализа входа RnB во время обмена с одним из банков NF_CS[3:0].*/ 
//reset default - 1111(0xF0)
#define NAND_CCSE_0 0x00‬ // установить неактивный уровень если RnB =0
#define NAND_CCSE_1 0xF0 // разрешить активный уровень на NF_CSx во время RnB=0

/*(30:21) "WTOC" - Длительность периода “time-out”. Эти биты определяют длительность периода, 
          используемого для контроля ситуации “time-out”. Превышение длительности RnB=0 над 
          длительностью периода WTOC•1024 приводит к ситуации “time-out” и установке бита TOEX.*/ 
//reset default - 0(0x0)

/*(31) "TOE" - Разрешение контроля ситуации “time-out”.*/ 
//reset default - 0(0x0)
#define NAND_TOE_0 0x00000000 // запрещено
#define NAND_TOR_1 0x80000000 // разрешено

/*____________________________________NAND_CFG____________________________________*/
/*Позволяет задать основные параметры флэш-памяти и режимы работы.*/

/*(2:0) "VOLCOL" - Размер страницы.*/ 
//reset default - 011(0x3)
#define NAND_VOLCOL_128  0x0 // 128  байта
#define NAND_VOLCOL_512  0x‬1 // 512  байта
#define NAND_VOLCOL_1024 0x2 // 1024 байта
#define NAND_VOLCOL_2048 0x3 // 2048 байта
#define NAND_VOLCOL_4096 0x4 // 4096 байта
#define NAND_VOLCOL_8192 0x5 // 8192 байта

/*(3) "ROWBT" - Размер страницы.*/ 
//reset default - 1(0x8)
#define NAND_ROWBT_2  0x0 // 2 байта
#define NAND_ROWBT_3  0x8 // 3 байта

/*(5:4) "COMCLW" - Число команд для записи.*/ 
//reset default - 01(0x10)
#define NAND_COMCLW_1  0x00 // 1
#define NAND_COMCLW_2  0x10 // 2
#define NAND_COMCLW_3  0x20 // 3 (расширенный режим)
#define NAND_COMCLW_R  0x‬30 // не используется

/*(7:6) "COMCLR" - Число команд для чтения.*/ 
//reset default - 01(0x40)
#define NAND_COMCLR_1   0x00 // 1
#define NAND_COMCLR_2   0x40 // 2
#define NAND_COMCLR_R1  0x80 // не используется
#define NAND_COMCLR_R2  0x‬C0 // не используется

/*(9:8) ADRCL" - Число адресных циклов.*/ 
//reset default - 11(0x300)
#define NAND_ADRCL_1           0x000 // 1 цикл
#define NAND_ADRCL_COLUMN      0x‬100 // только выбор столбца
#define NAND_ADRCL_LINE        0x200 // только выбор строки
#define NAND_ADRCL_LINE_COLUMN 0x300 // строка и столбец

/*(10) - Не используется.*/

/*(11) - Не используется.*/

/*(12) "ADRSC" - Управление пропуском адресного цикла.*/ 
//reset default - 0(0x0)
#define NAND_ADRSC_HAND_OVER 0x0000 // передавать адрес во время обмена
#define NAND_ADRSC_SKIP      0x‬1000 // пропустить

/*(13) "DATSC" - Управление пропуском цикла данных.*/ 
//reset default - 0(0x0)
#define NAND_DATSC_HAND_OVER 0x0000 // передавать адрес во время обмена
#define NAND_DATSC_SKIP      0x‬2000 // пропустить

/*(14) - Не используется.*/

/*(15) "COMSC" - Управление пропуском цикла передачи команд.*/ 
//reset default - 0(0x0)
#define NAND_COMSC_HAND_OVER 0x0000 // передавать адрес во время обмена
#define NAND_COMSC_SKIP      0x‬8000 // пропустить

/*(20:16) "RESBF" - Время задержки до анализа активности RnB. 
          Биты задают длительность (*2) периода от момента передачи последнего 
          байта адреса до момента анализа сигнала RnB.*/ 
//reset default - (0x1F)

/*(27:21) "RESAF" - Время задержки после завершения активности RnB.
          Биты задают длительность (*2) периода от момента, когда сигнал RnB 
          стал неактивным до момента чтения или записи данных.*/
//reset default - (0x7F)

/*(31:28) "ADDRH" - Биты адреса расширения.*/
//reset default - (0x0000)

/*____________________________________WR_CFG____________________________________*/
/*Регистры используются для задания значения команд, используемых при записи флэш-памяти.*/

/*(7:0) "COMW1" - первая команда записи*/
//reset default - (0x80)

/*(15:8) "COMW2" - вторая команда записи*/
//reset default - (0x00)

/*(23:16) "COMW3" - третья команда записи*/
//reset default - (0x10)

/*(24:31) - Не используется.*/

/*____________________________________RD_CFG____________________________________*/
/*Регистры используются для задания значения команд, используемых при чтении флэш-памяти.*/

/*(7:0) "COMR1" - первая команда чтения*/
//reset default - (0x00)

/*(15:8) "COMR2" - вторая команда чтения*/
//reset default - (0x30)

/*(23:16) "COMR3" - третья команда чтения*/
//reset default - (0x00)

/*(24:31) - Не используется.*/

/*____________________________________REGISTER_CR____________________________________*/
/*Регистр управления*/
/*После сброса значение регистра управления равно 0x0001, т.е. контроллер включен, настроен на 
чтение слов с размерностью шины данных в 32 бита. Далее будут описаны типовые процедуры чтения 
и записи данных. Они состоят из передачи управляющих команд, адреса и блока данных. Вся эта 
процедура выполняется, когда бит SQE равен нулю. Если установить бит SQE в единицу, указанный 
протокол будет выполняться для каждого слова данных, т.е. после передачи команды, адреса и чтения 
4-х байт данных (биты SZ равны 00), перед чтением следующих 4-х байт будет повторно выполнена 
передача команд и адреса. Данный режим очень медленный и не рекомендуется для применения.
Биты разрешения прерывания RIM, TIM, CIM могут быть использованы для организации работы контроллера 
вместе с процессором. Например, если выполняется чтение данных, разрешение прерывания RIM будет 
сигнализировать процессору о том, что во внутреннем буфере имеются данные для чтения. Если 
выполняется запись данных, разрешение прерывания ТIM будет сигнализировать процессору о том, что 
во внутреннем буфере имеется место для записи данных. Прерывание CIM сигнализирует процессору о 
завершении обмена, т.е. во внутренний буфер или из внутреннего буфера были передано количество слов 
данных указанное в счетчике CNTR.
Бит RW управляет направлением передачи данных. Значение 0 определяет чтение данных из внешней памяти
во внутренний буфер, а значение 1 задает передачу данных из внутреннего буфера во внешнюю память. 
Отметим, что чтение данных из внешней памяти инициируется только, если есть свободное место во 
внутреннем буфере, а запись во внешнюю память инициируется только когда есть данные во внутреннем 
буфере.
Бит EN разрешает работу контроллера. Если в данный бит записать ноль, произойдет очистка внутренних 
указателей внутреннего буфера и перевод машины состояний в исходное положение.
Биты SZ задают размер слова передаваемых данных. Размер 1 или 2 байта должен использоваться только 
для спецопераций.
Биты DBSZ задают размер шины данных FIFO. При смене размера шины необходимо выключить контроллер 
NAND флэш-памяти.*/

/*(0) "EN" - Разрешение работы.*/ 
#define NAND_ENABLE  0x1 //
#define NAND_DISABLE 0x0 // 

/*(1) "RW" - Разрешение работы.*/ 
#define NAND_READ  0x0 // чтение
#define NAND_WRITE 0x‬2 // запись

/*(2) - Не используется.*/

/*(3) "SQE" - Разрешение работы.*/ 
#define NAND_SQE_ENABLE  0x0 // разрешение последовательного доступа
#define NAND_SQE_DISABLE 0x‬4 // запрет последовательного доступа

/*(4) "RIM" - Разрешение прерывания при чтении.*/ 
#define NAND_RIM_ENABLE  0x10 // 
#define NAND_RIM_DISABLE 0x‬00 // 

/*(5) "TIM" - Разрешение прерывания при записи.*/ 
#define NAND_TIM_ENABLE  0x20 // 
#define NAND_TIM_DISABLE 0x‬00 // 

/*(6) "CIM" - Разрешение прерывания при достижении счетчика значения 0.*/ 
#define NAND_CIM_ENABLE  0x40 // 
#define NAND_CIM_DISABLE 0x‬00 // 

/*(7) - Не используется.*/

/*(9:8) "SZ" - Размер передаваемых данных.*/ 
#define NAND_SZ_1 0x300 // 1 байт 
#define NAND_SZ_2 0x‬200 // 2 байта 
#define NAND_SZ_4 0x‬000 // 4 байта 

/*(10) - Не используется.*/

/*(11) "DBSZ" - Размер шины данных FIFO контроллера.*/ 
#define NAND_DBSZ_32  0x000 // 32 байтa 
#define NAND_DBSZ_128 0x‬800 // 2 байта 

/*(12) "ERI_EN" - Разрешение прерывания в случае обнаружения ошибочной ситуации в 
       работе контроллера, т.е. когда обнаруживается ситуация тайм-аут.*/ 
#define NAND_ERI_ENABLE  0x1000 // 
#define NAND_ERI_DISABLE 0x‬0000 //

/*(13) "RnBI_EN" - Разрешение прерывания в случае обнаружения положительного фронта 
       на входе RnB, т.е. когда флаг RnB_Fрегистра состояния равен 1.*/ 
#define NAND_RnBI_ENABLE  0x2000 // 
#define NAND_RnBI_DISABLE 0x‬0000 //

/*(14) "EIM" - Pазрешение прерывания при обнаружении ошибки ЕСС.*/ 
#define NAND_EIM_ENABLE  0x4000 // 
#define NAND_EIM_DISABLE 0x‬0000 //

/*(15) "ECC_ON" - Bключение режима ЕСС.*/ 
#define NAND_ECC_ON  0x8000 // 
#define NAND_ECC_OFF 0x‬0000 //

/*____________________________________REGISTER_SR____________________________________*/
/*Отражает значение флагов запросов прерываний.*/

typedef union
{
  uint32_t REGISTER;
  struct
  {
    unsigned FIFO_EMPTY :1; // FIFO данных пусто (1)
    unsigned FIFO_FULL  :1; // FIFO данных заполнено полностью (1)
    unsigned TFS        :1; /* запрос от FIFO данных на запись новых данных 
                            процессором или контроллером прямого доступа. FIFO наполовину пусто (1)*/
    unsigned RFS        :1; /* запрос от FIFO данных на чтение новых данных процессором или 
                            контроллером прямого доступа. FIFO наполовину заполнено (1)*/
    unsigned IRQ        :3; /* общий запрос прерывания от контроллера. более детально причина 
                            запроса прерывания может быть установлена согласно состояния бит 20:16 
                            регистра.0 – нет запроса,1 – запрос на прерывание*/
    unsigned ZERO_0     :4; // не используется
    unsigned TOEX       :1; /* Флаги состояния Time-Out. биты отражают факт обнаружения 
                            ситуации “time-out” в процессе обмена с соответствующим NF_CSx.
                            0 – нет ошибки
                            1 – обнаружена ситуация “time-out”. биты очищаются программно, 
                            посредством записи в них 1*/
    unsigned ZERO_1     :1; // не используется
    unsigned RnB_F      :2; /* флаг изменения входа RnB из низкого уровня «0» в высокий «1» 
                            0 – не было изменения1 – был переход линии RnB из 0 в 1. 
                            бит очищается программно, посредством записи в него 1*/
    unsigned ZERO_2     :1; // не используется
    unsigned RFS_I      :1; /* запрос на прерывание когда RFS==1 и бит RIM==1. 
                            запрос может быть очищен посредством чтения буфера данных*/
    unsigned TFS_I      :1; /* запрос на прерывание когда ТFS==1 и бит ТIM==1. 
                            запрос может быть очищен посредством записи в буфер данных.*/
    unsigned CNTZ_I     :1; /* запрос на прерывание когда значение счетчика становится
                            равным нулю и бит СIM==1. 
                            запрос может быть очищен посредством записи нового значения счетчика*/
    unsigned ТО_I       :1; /* запрос на прерывание когда ТОЕХ==1 и бит ERI_EN ==1. 
                            запрос может быть очищен посредством записи 1 в бит ТОЕХ*/
    unsigned RnBF_I     :1; /* запрос на прерывание когда RnB_F ==1 и бит RnBI_EN ==1. 
                            запрос может быть очищен посредством записи 1 в бит RnB_F*/
    unsigned ZERO_3     :10;// не используется
    unsigned RnB        :1; // вход готовности NAND флэш-памяти. отражает состояние линии RnB

  } WORD;
} REGISTER_SR;

/*Функция записывает в аргумент размер страницы в Кбайтах, на работу с которым сейчас настроен NAND контролер.*/
static void NAND_GET_SIZE_PAGE( uint32_t* RAZMER )
{
  switch (NAND_NAND_CFG & 0x7)// Первые 3 бита (2:0) регистра NAND_CFG
  {
    case 0: *RAZMER = 128 ; puts("PAGE SIZE 128KB") ;   break;
    case 1: *RAZMER = 512 ; puts("PAGE SIZE 512KB") ;	break;
    case 2: *RAZMER = 1024; puts("PAGE SIZE 1024KB");	break;
    case 3: *RAZMER = 2048; puts("PAGE SIZE 2048KB");	break;
    case 4: *RAZMER = 4096; puts("PAGE SIZE 4096KB");	break;
    case 5: *RAZMER = 8192; puts("PAGE SIZE 8192KB");	break;
  }
}

//!!!!!  НЕ готова !!!!!
/*Функция очищает заданное количество Мбайт, начиная с нулевого адреса в NAND контролере.*/
/*static void NAND_ERASE_MEM(const uint32_t SIZE)
{
  uint32_t BLOCK,PAGE_SIZE;
  PAGE_SIZE = (NAND_NAND_CFG & 0x7);
  BLOCK = ((1024*1024) * SIZE)/(64 * PAGE_SIZE);
}*/

/*____________________________________OTHER____________________________________*/
/*Перечесление содержит имена моделей памяти Samsung для которых создан драйвер.*/
//K9F8G08UXM, K9F2G08X0B
typedef enum { _UXM, _X0B } SDRAM_type;

#endif
